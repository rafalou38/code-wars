Esoteric languages are pretty hard to program, but it's fairly interesting to write interpreters for them!

Your task is to write a method which will interpret Befunge-93 code! Befunge-93 is a language in which the code is presented not as a series of instructions, but as instructions scattered on a 2D plane; your pointer starts at the top-left corner and defaults to moving right through the code. Note that the instruction pointer wraps around the screen! There is a singular stack which we will assume is unbounded and only contain integers. While Befunge-93 code is supposed to be restricted to 80x25, you need not be concerned with code size. Befunge-93 supports the following instructions (from Wikipedia):

    [x] 0-9 Push this number onto the stack.
    [x] + Addition: Pop a and b, then push a+b.
    [x] - Subtraction: Pop a and b, then push b-a.
    [x] * Multiplication: Pop a and b, then push a*b.
    [x] / Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.
    [x] % Modulo: Pop a and b, then push the b%a. If a is zero, push zero.
    [x] ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
    [x] ` (backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
    [x] > Start moving right.
    [x] < Start moving left.
    [x] ^ Start moving up.
    [x] v Start moving down.
    [x] ? Start moving in a random cardinal direction.
    [x] _ Pop a value; move right if value = 0, left otherwise.
    [x] | Pop a value; move down if value = 0, up otherwise.
    [x] " Start string mode: push each character's ASCII value all the way up to the next ".
    [x] : Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
    [x] \ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
    [x] $ Pop value from the stack and discard it.
    [x] . Pop value and output as an integer.
    [x] , Pop value and output the ASCII character represented by the integer code that is stored in the value.
    [x] # Trampoline: Skip next cell.
    [x] p A "put" call (a way to store a value for later use). Pop y, x and v, then change the character at the position (x,y) in the program to the [ ] character with ASCII value v.
    [x] g A "get" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.
    [x] @ End program.
    [x] (i.e. a space) No-op. Does nothing.

The above list is slightly modified: you'll notice if you look at the Wikipedia page that we do not use the user input instructions and dividing by zero simply yields zero.

Here's an example:

> 987v>.v
> v456< :
> 321 ^ \_@

will create the output 123456789.

So what you must do is create a function such that when you pass in the Befunge code, the function returns the output that would be generated by the code. So, for example:

"123456789".equals(new BefungeInterpreter().interpret(">987v>.v\nv456< :\n>321 ^ \_@")

This test case will be added for you.
